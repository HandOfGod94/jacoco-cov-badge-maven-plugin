package io.github.handofgod94;

import com.opencsv.CSVReader;
import com.opencsv.CSVReaderBuilder;
import io.github.handofgod94.format.Formatter;
import io.github.handofgod94.format.JpegFormatter;
import io.github.handofgod94.format.PngFormatter;
import io.github.handofgod94.format.SvgFormatter;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import org.apache.batik.transcoder.TranscoderException;
import org.apache.pdfbox.pdmodel.font.PDFont;
import org.apache.pdfbox.pdmodel.font.PDMMType1Font;


/**
 * Utility class for generating badges.
 */
public class BadgeUtility {

  // extensions supported
  public static final String JPEG_EXT = "jpg";
  public static final String SVG_EXT = "svg";
  public static final String PNG_EXT = "png";

  // jacoco csv report column number
  public static final int INSTRUCTION_MISSED_COL_NO = 3;
  public static final int INSTRUCTION_COVERED_COL_NO = 4;
  public static final int BRANCH_MISSED_COL_NO = 5;
  public static final int BRANCH_COVERED_COL_NO = 6;
  public static final int LINE_MISSED_COL_NO = 7;
  public static final int LINE_COVERED_COL_NO = 8;
  public static final int COMPLEXITY_MISSED_COL_NO = 9;
  public static final int COMPLEXITY_COVERED_COL_NO = 10;
  public static final int METHOD_MISSED_COL_NO = 11;
  public static final int METHOD_COVERED_COL_NO = 12;


  /**
   * Calculates width of given string in pixels. Font size currently is 11,
   * default
   *
   * @param str input string needed
   * @return width in pixels as floating point value
   */
  public static float calculateWidth(String str) throws IOException {
    PDFont font = PDMMType1Font.HELVETICA;
    int fontSize = 12;
    float width = ((font.getStringWidth(str) / 1000) * fontSize) + 10.0f;
    return width;
  }

  /**
   * Calculate coverage %age from csv report generated by jacoco.
   *
   * @param csvPath Absolute path of csv report.
   * @param category enum representing the coverage category
   * @return integer value containing total coverage
   * @throws IOException Unable to read jacoco csv report from config location
   * @throws NumberFormatException Unable to parse %ages from jacoco reports
   * @see io.github.handofgod94.Badge.CoverageCategory
   */
  public static int calculateCoverage(String csvPath, Badge.CoverageCategory category)
      throws NumberFormatException, IOException {
    CSVReader reader =
        new CSVReaderBuilder(new FileReader(csvPath)).withSkipLines(1).build();

    long instructionsMissed = 0;
    long instructionsCovered = 0;
    int missedColNo = getMissedColNo(category);
    int coveredColNo = getCoveredColNo(category);

    String[] line;
    while (null != (line = reader.readNext())) {
      if (line[missedColNo] != null && !line[missedColNo].equals("")) {
        instructionsMissed += Integer.parseInt(line[missedColNo]);
      }

      if (line[coveredColNo] != null && !line[coveredColNo].equals("")) {
        instructionsCovered += Integer.parseInt(line[coveredColNo]);
      }
    }
    reader.close();

    // calculate coverage
    float totalInstructions = instructionsCovered + instructionsMissed;
    float coveragePercent = (instructionsCovered / totalInstructions) * 100.0f;
    int coverage = (int) Math.floor(coveragePercent);
    return coverage;
  }

  /**
   * Get correct color for the given %age range.
   * %age range is mapped to a particular color.
   * <table>
   *   <tr>
   *     <td>Coverage %age</td>
   *     <td>Color Enum</td>
   *   </tr>
   *   <tr>
   *     <td>[0, 40)</td>
   *     <td>RED</td>
   *   </tr>
   *   <tr>
   *     <td>[40, 50)</td>
   *     <td>ORANGE</td>
   *   </tr>
   *   <tr>
   *     <td>[50, 60)</td>
   *     <td>YELLOW</td>
   *   </tr>
   *   <tr>
   *     <td>[60, 70)</td>
   *     <td>YELLOWGREEN</td>
   *   </tr>
   *   <tr>
   *     <td>[70, 80)</td>
   *     <td>GREEN</td>
   *   </tr>
   *   <tr>
   *     <td>[80, 100)</td>
   *     <td>BRIGHTGREEN</td>
   *   </tr>
   * </table>
   *
   * @param coverage coverage percentage rounded off to nearest integer
   * @return An Enum for the given range
   * @see io.github.handofgod94.BadgeColors
   */
  public static BadgeColors getColorFromRange(int coverage) {
    // TODO: Grey for invalid coverage
    if (coverage >= 0 && coverage < 40) {
      return BadgeColors.RED;
    } else if (coverage >= 40 && coverage < 50) {
      return BadgeColors.ORANGE;
    } else if (coverage >= 50 && coverage < 60) {
      return BadgeColors.YELLOW;
    } else if (coverage >= 60 && coverage < 70) {
      return BadgeColors.YELLOWGREEN;
    } else if (coverage >= 70 && coverage < 80) {
      return BadgeColors.GREEN;
    } else {
      return BadgeColors.BRIGHTGREEN;
    }
  }

  private static int getMissedColNo(Badge.CoverageCategory category) {
    switch (category) {
      case INSTRUCTION: return INSTRUCTION_MISSED_COL_NO;
      case LINE: return LINE_MISSED_COL_NO;
      case BRANCH: return BRANCH_MISSED_COL_NO;
      case COMPLEXITY: return COMPLEXITY_MISSED_COL_NO;
      case METHOD: return METHOD_MISSED_COL_NO;
      default: return INSTRUCTION_MISSED_COL_NO;
    }
  }

  private static int getCoveredColNo(Badge.CoverageCategory category) {
    switch (category) {
      case INSTRUCTION: return INSTRUCTION_COVERED_COL_NO;
      case LINE: return LINE_COVERED_COL_NO;
      case BRANCH: return BRANCH_COVERED_COL_NO;
      case COMPLEXITY: return COMPLEXITY_COVERED_COL_NO;
      case METHOD: return METHOD_COVERED_COL_NO;
      default: return INSTRUCTION_COVERED_COL_NO;
    }
  }

  /**
   * Generates output file based on the extension give in configuration.
   * It expects renderedText to filled in with the actual data, coverage percentage
   * and label of the badge.
   *
   * @param outputFile output file object pointing to badge location
   * @param renderedText rendered svg template having all the required data
   * @throws IOException if it's unable to perform file operations for the output.
   * @throws TranscoderException if it fails to convert svg rendered text to required format.
   */
  public static void generateFileBasedOnExt(File outputFile, String renderedText)
      throws IOException, TranscoderException {

    String extension = outputFile.getName().substring(outputFile.getName().lastIndexOf(".") + 1);
    Formatter formatter;

    if (extension.equals(JPEG_EXT)) {
      formatter = new JpegFormatter();
    } else if (extension.equals(PNG_EXT)) {
      formatter = new PngFormatter();
    } else {
      // By default render SVG
      formatter = new SvgFormatter();
    }

    formatter.save(outputFile, renderedText);

  }
}
